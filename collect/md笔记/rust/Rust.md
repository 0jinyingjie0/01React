# Rust

## 基础语法

### 变量

首先必须说明，Rust 是强类型语言，但具有自动判断变量类型的能力。这很容易让人与弱类型语言产生混淆。

如果要声明变量，需要使用 let 关键字。例如：

```
let a = 123;
```

这就牵扯到了 Rust 语言为了高并发安全而做的设计：在语言层面尽量少的让变量的值可以改变。所以 a 的值不可变。但这不意味着 a 不是"变量"（英文中的 variable），官方文档称 a 这种变量为"不可变变量"。

如果我们编写的程序的一部分在假设值永远不会改变的情况下运行，而我们代码的另一部分在改变该值，那么代码的第一部分可能就不会按照设计的意图去运转。由于这种原因造成的错误很难在事后找到。这是 Rust 语言设计这种机制的原因。

当然，使变量变得"可变"（mutable）只需一个 mut 关键字。

```
let mut a = 123;
a = 456;
```

### 常量与不可变变量的区别

既然不可变变量是不可变的，那不就是常量吗？为什么叫变量？

变量和常量还是有区别的。在 Rust 中，以下程序是合法的：

```
let a = 123;
let a = 456;
```

但是如果 a 是常量就不合法：

```
const a: i32 = 123;
let a = 456;
```

变量的值可以"重新绑定"，但在"重新绑定"以前不能私自被改变，这样可以确保在每一次"绑定"之后的区域里编译器可以充分的推理程序逻辑。 虽然 Rust 有自动判断类型的功能，但有些情况下声明类型更加方便：

```
let a: u64 = 123;
```

这里声明了 a 为无符号 64 位整型变量，如果没有声明类型，a 将自动被判断为有符号 32 位整型变量，这对于 a 的取值范围有很大的影响。

### 重影（Shadowing）

重影的概念与其他面向对象语言里的"重写"（Override）或"重载"（Overload）是不一样的。重影就是刚才讲述的所谓"重新绑定"，之所以加引号就是为了在没有介绍这个概念的时候代替一下概念。

重影就是指变量的名称可以被重新使用的机制：

### 实例

fn main() {
  let x = 5;
  let x = x + 1;
  let x = x * 2;
  println!("The value of x is: {}", x);
}

这段程序的运行结果：

```
The value of x is: 12
```

重影与可变变量的赋值不是一个概念，重影是指用同一个名字重新代表另一个变量实体，其类型、可变属性和值都可以变化。但可变变量赋值仅能发生值的变化。

```
let mut s = "123";
s = s.len();
```

这段程序会出错：不能给字符串变量赋整型值。

## 数据类型

### 整数型（Integer）

整数型简称整型，按照比特位长度和有无符号分为一下种类：

| 位长度  | 有符号 | 无符号 |
| :------ | :----- | :----- |
| 8-bit   | i8     | u8     |
| 16-bit  | i16    | u16    |
| 32-bit  | i32    | u32    |
| 64-bit  | i64    | u64    |
| 128-bit | i128   | u128   |
| arch    | isize  | usize  |

isize 和 usize 两种整数类型是用来衡量数据大小的，它们的位长度取决于所运行的目标平台，如果是 32 位架构的处理器将使用 32 位位长度整型。

整数的表述方法有以下几种：

| 进制                 | 例          |
| :------------------- | :---------- |
| 十进制               | 98_222      |
| 十六进制             | 0xff        |
| 八进制               | 0o77        |
| 二进制               | 0b1111_0000 |
| 字节(只能表示 u8 型) | b'A'        |

很显然，有的整数中间存在一个下划线，这种设计可以让人们在输入一个很大的数字时更容易判断数字的值大概是多少。

### 浮点数型（Floating-Point）

Rust 与其它语言一样支持 32 位浮点数（f32）和 64 位浮点数（f64）。默认情况下，64.0 将表示 64 位浮点数，因为现代计算机处理器对两种浮点数计算的速度几乎相同，但 64 位浮点数精度更高。

### 实例

fn main() {
  let x = 2.0; *// f64*
  let y: f32 = 3.0; *// f32*
}

### 数学运算

用一段程序反应数学运算：

### 实例

fn main() {
  let sum = 5 + 10; *// 加*
  let difference = 95.5 - 4.3; *// 减*
  let product = 4 * 30; *// 乘*
  let quotient = 56.7 / 32.2; *// 除*
  let remainder = 43 % 5; *// 求余*
}

许多运算符号之后加上 = 号是自运算的意思，例如：

**sum += 1** 等同于 **sum = sum + 1**。

**注意：**Rust 不支持 **++** 和 **--**，因为这两个运算符出现在变量的前后会影响代码可读性，减弱了开发者对变量改变的意识能力。

### 布尔型

布尔型用 bool 表示，值只能为 true 或 false。

### 字符型

字符型用 char 表示。

Rust的 char 类型大小为 4 个字节，代表 Unicode标量值，这意味着它可以支持中文，日文和韩文字符等非英文字符甚至表情符号和零宽度空格在 Rust 中都是有效的 char 值。

Unicode 值的范围从 U+0000 到 U+D7FF 和 U+E000 到 U+10FFFF （包括两端）。 但是，"字符"这个概念并不存在于 Unicode 中，因此您对"字符"是什么的直觉可能与Rust中的字符概念不匹配。所以一般推荐使用字符串储存 UTF-8 文字（非英文字符尽可能地出现在字符串中）。

**注意：**由于中文文字编码有两种（GBK 和 UTF-8），所以编程中使用中文字符串有可能导致乱码的出现，这是因为源程序与命令行的文字编码不一致，所以在 Rust 中字符串和字符都必须使用 UTF-8 编码，否则编译器会报错。

### 复合类型

元组用一对 **( )** 包括的一组数据，可以包含不同种类的数据：

### 实例

let tup: (i32, f64, u8) = (500, 6.4, 1);
*// tup.0 等于 500*
*// tup.1 等于 6.4*
*// tup.2 等于 1*
let (x, y, z) = tup;
*// y 等于 6.4*

数组用一对 **[ ]** 包括的同类型数据。

### 实例

let a = [1, 2, 3, 4, 5];
*// a 是一个长度为 5 的整型数组*

let b = ["January", "February", "March"];
*// b 是一个长度为 3 的字符串数组*

let c: [i32; 5] = [1, 2, 3, 4, 5];
*// c 是一个长度为 5 的 i32 数组*

let d = [3; 5];
*// 等同于 let d = [3, 3, 3, 3, 3];*

let first = a[0];
let second = a[1];
*// 数组访问*

a[0] = 123; *// 错误：数组 a 不可变*
let mut a = [1, 2, 3];
a[0] = 4; *// 正确*

## 函数

其中 Rust 函数名称的命名风格是小写字母以下划线分割：

## 实例

fn main() {
  println!("Hello, world!");
  another_function();
}

fn another_function() {
  println!("Hello, runoob!");
}

运行结果：

```
Hello, world!
Hello, runoob!
```

注意，我们在源代码中的 main 函数之后定义了another_function。 Rust不在乎您在何处定义函数，只需在某个地方定义它们即可。

### 函数参数

Rust 中定义函数如果需要具备参数必须声明参数名称和类型：

## 实例

fn main() {
  another_function(5, 6);
}

fn another_function(x: i32, y: i32) {
  println!("x 的值为 : {}", x);
  println!("y 的值为 : {}", y);
}

运行结果：

```
x 的值为 : 5
y 的值为 : 6
```

### 函数体的语句和表达式

Rust 函数体由一系列可以以表达式（Expression）结尾的语句（Statement）组成。到目前为止，我们仅见到了没有以表达式结尾的函数，但已经将表达式用作语句的一部分。

语句是执行某些操作且没有返回值的步骤。例如：

```
let a = 6;
```

这个步骤没有返回值，所以以下语句不正确：

```
let a = (let b = 2);
```

表达式有计算步骤且有返回值。以下是表达式（假设出现的标识符已经被定义）：

```
a = 7
b + 2
c * (a + b)
```

Rust 中可以在一个用 **{}** 包括的块里编写一个较为复杂的表达式：

## 实例

fn main() {
  let x = 5;

  let y = {
    let x = 3;
    x + 1
  };

  println!("x 的值为 : {}", x);
  println!("y 的值为 : {}", y);
}

运行结果：

```
x 的值为 : 5
y 的值为 : 4
```

很显然，这段程序中包含了一个表达式块：

```
{
    let x = 3;
    x + 1
};
```

而且在块中可以使用函数语句，最后一个步骤是表达式，此表达式的结果值是整个表达式块所代表的值。这种表达式块叫做函数体表达式。

注意：**x + 1** 之后没有分号，否则它将变成一条语句！

这种表达式块是一个合法的函数体。而且在 Rust 中，函数定义可以嵌套：

## 实例

fn main() {
  fn five() -> i32 {
    5
  }
  println!("five() 的值为: {}", five());
}

### 函数返回值

在上一个嵌套的例子中已经显示了 Rust 函数声明返回值类型的方式：在参数声明之后用 **->** 来声明函数返回值的类型（不是 **:** ）。

在函数体中，随时都可以以 return 关键字结束函数运行并返回一个类型合适的值。这也是最接近大多数开发者经验的做法：

### 实例

fn add(a: i32, b: i32) -> i32 {
  return a + b;
}

但是 Rust 不支持自动返回值类型判断！如果没有明确声明函数返回值的类型，函数将被认为是"纯过程"，不允许产生返回值，return 后面不能有返回值表达式。这样做的目的是为了让公开的函数能够形成可见的公报。

**注意：**函数体表达式并不能等同于函数体，它不能使用 **return** **关键字。**